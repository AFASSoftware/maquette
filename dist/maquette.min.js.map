{"version":3,"sources":["maquette.js","../../../../src/maquette.ts"],"names":["Object","defineProperty","exports","value","createDom","updateDom","NAMESPACE_SVG","NAMESPACE_W3","emptyArray","extend","base","overrides","result","keys","forEach","key","same","vnode1","vnode2","vnodeSelector","properties","bind","toTextVNode","data","undefined","children","text","toString","domNode","appendChildren","parentSelector","insertions","main","i","length_1","length","item","Array","isArray","hasOwnProperty","push","missingTransition","Error","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","split","token","classList","add","classNames","classNameCount","j","className","styleNames","styleCount","type","lastIndexOf","oldPropValue","evt","apply","this","target","setAttributeNS","setAttribute","_loop_1","updateProperties","previousProperties","propertiesUpdated","previousValue","on","remove","newStyleValue","domValue","removeAttribute","findIndexOfChild","sameAs","start","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","node","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","oldChild","newChild","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertNode","beforeNode","beforeAttach","insertBefore","appendChild","c","found","delayAttach","doc","ownerDocument","createTextNode","charAt","slice","id","createElementNS","createElement","previous","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","update","updatedVnode","h","selector","arguments","childIndex","argsLength","onlyChild","child","dom","create","document","append","merge","element","replace","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","stopped","projections","renderFunctions","doRender","renderNow","requestAnimationFrame","stop","cancelAnimationFrame","resume","renderMaquetteFunction","detach","splice"],"mappings":"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","file":"maquette.min.js","sourcesContent":["(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    'use strict';\n    // Comment that is displayed in the API documentation for the maquette module:\n    /**\n * Welcome to the API documentation of the **maquette** library.\n *\n * [[http://maquettejs.org/|To the maquette homepage]]\n */\n    Object.defineProperty(exports, '__esModule', { value: true });\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        var _loop_1 = function (i) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName !== 'key' && propValue !== null && propValue !== undefined) {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    oldPropValue.apply(this, [evt]);\n                                    evt.target['oninput-value'] = evt.target.value;    // may be HTMLTextAreaElement as well\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        };\n        for (var i = 0; i < propCount; i++) {\n            _loop_1(i);\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    var domValue = domNode[propName];\n                    if (domValue !== propValue    // The 'value' in the DOM tree !== newValue\n&& (domNode['oninput-value'] ? domValue === domNode['oninput-value']    // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput\n : propValue !== previousValue    // Only update the value if the vdom changed\n)) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else if (propName === 'role' && propValue === '') {\n                            domNode.removeAttribute(propName);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children\n            ]);\n        }\n    };\n    var insertNode = function (parentNode, domNode, vnode, beforeNode) {\n        if (vnode.properties && vnode.properties.beforeAttach) {\n            vnode.properties.beforeAttach.apply(vnode.properties.bind || vnode.properties, [\n                parentNode,\n                domNode\n            ]);\n        }\n        if (beforeNode) {\n            parentNode.insertBefore(domNode, beforeNode);\n        } else if (domNode.parentNode !== parentNode) {\n            parentNode.appendChild(domNode);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var delayAttach = !!(vnode.properties && vnode.properties.delayAttach);\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        var doc = parentNode.ownerDocument;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = doc.createTextNode(vnode.text);\n            if (!delayAttach) {\n                insertNode(parentNode, domNode, vnode, insertBefore);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = vnode.domNode || doc.createElement(found);\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute('type', vnode.properties.type);\n                            }\n                        }\n                        if (!delayAttach) {\n                            insertNode(parentNode, domNode, vnode, insertBefore);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n            if (delayAttach) {\n                insertNode(parentNode, domNode, vnode, insertBefore);\n            }\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = domNode.ownerDocument.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text;\n        var children;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < argsLength; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new child node to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new child node.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Replaces an existing DOM node with a node generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param element - The node for the [[VNode]] to replace.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        replace: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, element.parentNode, element, projectionOptions);\n            element.parentNode.removeChild(element);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs;\n        var cachedOutcome;\n        return {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectorOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));",null]}